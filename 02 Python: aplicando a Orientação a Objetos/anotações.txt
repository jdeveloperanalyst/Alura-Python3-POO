token github 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

- Classes -

Analise o script abaixo:
'''
class Restaurante:
    nome = ''
    categoria = ''
    ativo = False

restaurante_praca = Restaurante()
restaurante_praca.nome = 'Praça'
restaurante_praca.categoria = 'Gourmet'

restaurante_pizza = Restaurante()

restaurantes = [restaurante_praca, restaurante_pizza]

print(dir(restaurante_praca))
'''

OUTPUT:
'''
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'ativo', 'categoria', 'nome']
'''

---> Analisando o output, sempre que no valor do objeto possuir __class__ ou qualquer atributo que começe com 'underline', significa que é um método especial,
que toda classe em python vai ter.

---> Analisando o script, temos a função 'dir()': print(dir(restaurante_praca)), passando o objeto como parâmetro dentro dessa função, ela irá exibir todos as propriedades, atributos e métodos deste objeto conforme output mostrado acima.
Esta função faz sentido ser utilizado quando se trata de uma classe que não conhecemos para visualizar as propriedades, atributos ou metódos de determinado objeto de uma classe.

-----------------------------------------------------------------

Analise o script abaixo:

'''
class Restaurante:
    nome = ''
    categoria = ''
    ativo = False

restaurante_praca = Restaurante()
restaurante_praca.nome = 'Praça'
restaurante_praca.categoria = 'Gourmet'

restaurante_pizza = Restaurante()

restaurantes = [restaurante_praca, restaurante_pizza]

print(vars(restaurante_praca))
'''

OUTPUT:
'''
{'nome': 'Praça', 'categoria': 'Gourmet'}
'''

---> Analisando o script e o output, vemos que ao utilizar a função 'vars', conseguimos ver um dicionário desses atributos e métodos.

-----------------------------------------------------------------

Convenções de nomes para variáveis e funções no Python?

Segundo as convenções de nomenclatura do próprio Python Enhancement Proposal 8, algumas preocupações incluem:

Evitar certos nomes

Nunca usar os caracteres 'l', 'O', ou 'I' como nomes de variáveis pois, em algumas fontes, eles são indistinguíveis dos números um e zero.

Pacote e nomes de módulos

Os módulos devem ter nomes pequenos, sendo estes escritos em minúsculo por completo.

Ex: package

Nomes de classes

Os nomes de classes têm a primeira letra de cada palavra maiúscula (CamelCase).

Ex: NomeDeUmaClasse

Nomes de funções e métodos

Nomes de funções e métodos devem estar em letras minúsculas, com palavras separadas por underscores conforme seja útil para a legibilidade.

Ex: nome_de_uma_funcao

Obs: o caso misto (todas as iniciais maiúsculas, com exceção da primeira) é permitido apenas em contextos onde isso já é o estilo predominante, para manter compatibilidade com versões anteriores.

Constantes

Constantes são geralmente definidas em um nível de módulo e escritas em letras maiúsculas com underscores separando as palavras. Exemplos incluem MAX_OVERFLOW e TOTAL.

Nomes de variáveis e parâmetros de funções e métodos

Geralmente seguem a mesma regra das funções, devendo estar em letras minúsculas, com palavras separadas por underscores conforme seja útil para a legibilidade.

Obs: Usar self como primeiro parâmetro de um método.

Ex: nome_de_um_metodo(self):

Identação

A identação deve ser feita usando quatro espaços por nível.

Linhas em branco

Linhas em branco são recomendadas para separar funções e definições de classes (duas linhas), além de definições de métodos (uma linha).

Espaços em branco

O espaço em branco deve ser usado para separar operadores matemáticos, binários, de comparação e de atribuição de outros elementos.

Ex:

if variavel == False:
    print 2 * 3
Deve-se evitar o uso de espaços em branco entre parênteses e parâmetros na declaração de uma função, bem como entre uma chamada de função e o primeiro parêntese de sua lista de argumentos.

Ex: funcao(primeiro_parametro, segundo_parametro)

-----------------------------------------------------------------

---> O __init__ é um método especial/método construtor que garante que toda vez que criado uma 
instância da classe Restaurante() ela inicie obrigatóriamente com os atributos definidos 
dentro de __init__ que está definido dentro da classe Restaurante. Ele serve para inicializar (ou seja, configurar) o objeto.

conforme abaixo:

'''
class Restaurante:
    def __init__(self, nome, categoria):
        self.nome = nome
        self.categoria = categoria
        self.ativo = False

restaurante_praca = Restaurante('Praça', 'Gourmet')
restaurante_pizza = Restaurante('Pizza Express', 'Italiana')

restaurantes = [restaurante_praca, restaurante_pizza]

print(vars(restaurante_praca))
print(vars(restaurante_pizza))
'''

---> O self é uma referência à instância atual da classe e é usado para acessar as variáveis que pertencem à classe,
ou seja, é possível utilizar o self para acessar o mesmo método do objeto mudando seu estado.
O self em Python é uma convenção que representa a instância da própria classe. Ele é usado como o primeiro parâmetro 
em métodos de instância (métodos pertencentes a objetos específicos da classe).

----> O __srt__ é um método especial que pega o objeto e mostra sua estrutura em formato de texto.
Em outras palavras _str__ é usado para fornecer uma representação de string de uma instância. 
verifique abaixo:

'''
class Restaurante:
    def __init__(self, nome, categoria):
        self.nome = nome
        self.categoria = categoria
        self.ativo = False
        
    def __str__(self):
        return f'{self.nome} | {self.categoria}'

restaurante_praca = Restaurante('Praça', 'Gourmet')
restaurante_pizza = Restaurante('Pizza Express', 'Italiana')

restaurantes = [restaurante_praca, restaurante_pizza]

print(restaurante_praca)
print(restaurante_pizza)
'''

OUTPUT definindo o método __str__ fornece uma representação de string de uma instância/objeto:
'''
Praça | Gourmet
Pizza Express | Italiana
'''

OUTPUT apenas com o método construtor __init__, mostra apenas o endereço de memória do objeto:
'''
<__main__.Restaurante object at 0x7f6034457e80>
<__main__.Restaurante object at 0x7f6034457e20>
'''

---> Então com o método espeial __str__ podemos identificar qualquer informação relacionado ao 
objeto que estamos criando.

-----------------------------------------------------------------

- Vamos partir de um princípio do Python muito importante, que é modificar como um atributo
é lido. Para isso, abaixo do bloco listar_restaurantes, vamos utilizar um símbolo diferente,
que é o @, um decorator (decorador) do Python.

- Vamos escrever @property. O que isso vai fazer? Quando escrevemos @property, temos a capacidade
de pegar um atributo — neste caso, o ativo.

- Sempre que utilizarmos @property, queremos modificar como aquele atributo vai ser lido.

- mostrar o valor false ou true não explica muito bem o que está acontecendo. Então, podemos 
colocar no interior dessa função um return, por exemplo. Queremos retornar determinada informação.

- À direita do return, vamos adicionar um 'verdadeiro' if self.ativo para mostrarmos algo no
caso do self.ativo ser verdadeiro. Adicionaremos um else 'false' para retornar algo diferente 
caso não for verdadeiro.

- Adicionamos true e false. Igual fizemos no curso anterior, só que antes escrevemos ativo e
desativado.

Vamos colocar um emoji?

https://coolsymbol.com/

Vamos escolher e copiar os ícones abaixo:

- O ícone ⌧ denominado "X in a Rectangle Box", constituído de um quadrado com um xis dentro, para
utilizarmos se for ativo.
- O ícone ☐ denominado "Ballot Box", constituído de um quadrado vazio, para utilizarmos se for 
false.

- Estamos usando emojis para modificar como o atributo que vai ser exibido. No mundo real, no projeto
real, podemos usar a @property para realizar uma operação matemática ou para recolher diversos valores 
e agrupar em um só, e assim por diante.

- Fizemos esse exemplo. Se for true, vai aparecer o quadrado com um xis dentro. Se for false, vai
aparecer o quadrado vazio.

'''
class Restaurante:
    restaurantes = []
    
    def __init__(self, nome, categoria):
        self.nome = nome
        self.categoria = categoria
        self.ativo = False
        Restaurante.restaurantes.append(self)
        
    def __str__(self):
        return f'{self.nome} | {self.categoria}'

    def listar_restaurantes():
        for restaurante in Restaurante.restaurantes:
            print(f'{restaurante.nome} | {restaurante.categoria} | {restaurante.ativo}')
    
    @property
    def ativo(self):
        return '☑' if  self.ativo else '☐'
    
restaurante_praca = Restaurante('Praça', 'Gourmet')
restaurante_pizza = Restaurante('Pizza Express', 'Italiana')

Restaurante.listar_restaurantes()

'''

- Ao executar o script desta forma acima, teremos uma mensagem de erro vai dizer que "a propriedade 
ativo não tem um setter". O que isso significa? Significa que não somos capazes de mudar
o ativo.

- Um “setter” é um tipo de método em programação orientada a objetos que é usado para controlar
as alterações a uma variável. É parte do conceito de encapsulamento. Em Python, um setter
permite que você defina regras para quando uma variável é alterada.

- Por que não somos capazes? Não recebemos o ativo como parâmetro na função __init__(), somente o definimos ele como false.

- Poderíamos mudar o nome do restaurante, por exemplo, com restaurante_praca.ativo igual a true. Contudo, não
queremos que as pessoas mudem o ativo do restaurante só digitando ali o nome do restaurante. 
Isso não faz sentido e não seria seguro.

- O que talvez faça mais sentido é termos um método que muda esse estado, igual já havíamos
feito. Para isso, vamos dizer que ativo é um atributo, mas ele é um atributo privado. 
Não esperamos que as pessoas alterem o valor dele.

- Para isso, na função __init__(), substituiremos a linha self.ativo por self._ativo. 
Essa mudança indica que não estamos esperando que as pessoas acessem ele direto. 
Em vez disso, elas vão usar a propriedade.

- Como colocamos o _ na função __init__(), também precisamos colocar o 
_ na linha return '⌧' if self.ativo else '☐' da função ativo(), onde de fato modificamos
esse ativo.

- Então, toda vez que acessarmos esse atributo, também temos que colocar o _.

- É importante mencionar que essa mudança não está exatamente deixando o atributo privado.
Ele está deixando-o apenas como protegido. É como se fosse uma convenção que utilizamos para
informar que aquele atributo não deve ser alterado.

- Executando o código no terminal, veremos que apareceu um quadrado vazio para ambos.

-----------------------------------------------------------------

- Para manter todas as palavras que temos com iniciais maiúsculas, na função __init__(), 
podemos usar uma função do Python chamada .title(). Ela será aplicada à esquerda de nome,
na linha self.nome = nome, que possui o nome do restaurante.

self.nome = nome.title()

- Se quisermos que a categoria seja sempre escrita com todas as letras maiúsculas, podemos 
usar o método .upper() à esquerda de categoria, na linha self.categoria = categoria.

self.categoria = categoria.upper()

- Portanto, nem sempre precisaremos usar property para todos os valores que temos em nossa
aplicação.

- Entretanto, é importante que os atributos da classe fiquem visíveis para a classe, e que
não possamos alterá-los sem controle.

- Isso nos leva a um ponto importante: podemos definir o nome e a categoria também como atributos
privados da classe.

- Para alterar todas as ocorrências de um atributo ao mesmo tempo, podemos selecionar um deles
e apertar "F2". Faremos isso com atributo nome.

- Isso nos permite digitar um novo nome e renomear todos os locais em que ele aparece. 
Nesse caso, adicionaremos um sublinhado antes do nome, transformando-o em _nome.

- Resumindo, a boa prática é definir todos os nossos atributos com um sublinhado antes.

- Precisamos de property para tudo? Não necessariamente. Usamos property quando precisamos
encapsular informações que serão cruzadas com outras para gerar uma visualização diferente. 
Caso contrário, podemos aplicar a mudança diretamente nos parâmetros quando instanciamos o objeto.

- No caso do nosso projeto, precisamos de uma validação melhor para o atributo ativo, então
criamos uma property. Mas no caso do nome e da categoria, não precisamos da property para
fazer a mudança desses atributos.

-----------------------------------------------------------------

- Criamos métodos especiais na classe Restaurante: o __init__() e o __str__(). Criamos nossos próprios
métodos, como listar_restaurantes() e criamos uma property.

- Trabalhando com tipos de método diferentes

- A questão importante é que não precisamos criar nenhuma instância para listarRestaurante. 
Não precisamos especificar o nome dele nem sua categoria. Bastou adicionar no fim 
do arquivo o Restaurante com o R maiúsculo indicando que é a classe, junto a .listarRestaurantes.

- É uma boa prática indicar que se trata de um método da classe sempre que temos um método que não
está referenciado com uma instância, mas sim à classe. Para isso utilizamos o @classmethod — vamos 
adicioná-lo acima de listar_restaurantes().

- Sempre que temos um @classmethod e estamos utilizando informações referentes a esse método, podemos
colocar como argumento entre os parênteses do método um cls. Se trata de uma convenção também.

- Por fim, na linha for restaurante in Restaurante.restaurantes, em vez de usar o 
Restaurante com inicial maiúscula, vamos usar o cls, para indicar que se trata de 
um método da classe, um @classmethod.

'''
@classmethod
def listar_restaurantes(cls):
    print(f'{'Nome do restaurante'.ljust(25)} | {'Categoria'.ljust(25)} | {'Status'}')
    for restaurante in cls.restaurantes:
        print(f'{restaurante._nome.ljust(25)} | {restaurante._categoria.ljust(25)} | {restaurante.ativo}')

'''

- Em métodos de classe, não precisamos da instância de objetos dela. Com a própria
classe já conseguimos acessar esses métodos.

- O nosso código que já estava funcionando, agora está mais legível e mais próximo do
que acontece no mundo real de desenvolvimento. Podemos ter métodos da classe, exclusivos
para a classe, nos quais não precisamos de instâncias de objetos, e também temos métodos
 especiais ou métodos para alterar um estado de algo na classe.

- Agora nós precisamos garantir de alguma forma que somos capazes de ativar um restaurante.

- E podemos criar outro método exatamente para ativar o estado, ou mudar, no caso, o estado
do nosso ativo.

- Esse método, diferente do método de listar restaurantes, não é um método para a classe
restaurante, mas para os objetos. Então ele não é um @classmethod.

- Ele não é um método da classe.

- Vamos criá-lo abaixo da property ativo e chamá-lo de alternar_estado().

- Em seu interior, vamos precisar daquela referência. É possível aproveitar aquela
mesma lógica que tínhamos feito antes. Ou seja, pegar o self._ativo que estamos 
pedindo agora, e alternar o estado dele colocando o not, já que ele é um booliano.

- Então seria o self._ativo, que será igual ao not self.ativo.

'''
def alternar_estado(self)
    self._ativo = not self._ativo

'''

- Isso é interessante. Existem alguns tipos de métodos dentro de uma classe. Esse método
alternar_estado, que acabamos de criar, é um método para os objetos.

- Quando executamos, temos o nome do restaurante "Praça", categoria "GOURMET" e o status dele
é o quadrado com um 'check' dentro, indicando que ele está ativo.

CONSIDERAÇÕES:

- Nesta aula, vimos que uma classe é uma estrutura que encapsula dados e comportamentos
relacionados. Além disso, os métodos em uma classe podem ser classificados em vários
tipos com base em sua natureza e propósito.

- Ao criar classes, você pode implementar esses métodos para fornecer funcionalidades
específicas e controla o comportamento da instância e da classe.

Veja o exemplo desta classe:

'''
class Contador:
    '''
    Classe que representa um contador.
    A instância mantém um contador específico, enquanto um contador global é compartilhado por todas as instâncias.
    '''

    contador_global = 0

    def __init__(self):
        self.valor = 0

    def __str__(self):
        return f'Contador: {self.valor}'

    def incrementar(self):
        self.valor += 1

    @classmethod
    def zerar_contador_global(cls):
        cls.contador_global = 0
        return 'Contador global foi zerado.'

'''

- O método init é o construtor usado para inicializar uma instância da classe.
    . Isso aí! O método __init__ é conhecido como o construtor da classe em Python.
      Ele é automaticamente chamado quando uma nova instância da classe é criada e serve
      para realizar as inicializações necessárias nos atributos da instância. O nome __init__ 
      é uma abreviação de initialize (inicializar), e sua principal função é garantir que os
      atributos da instância tenham valores iniciais apropriados.

    . A classe Contador tem um método de instância incrementar que aumenta o valor do contador
      e um método __str__ para fornecer uma representação em string da instância.

-----------------------------------------------------------------

